! Module  : util_m
! Purpose : miscellaneous utility routines
!
! Copyright 2013-2020 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module util_m

   ! Uses

   use forum_m, only: RD, reallocate

   use constants_m
   use grid_par_m
   use math_m
   use mode_par_m
   use num_par_m
   use orbit_par_m
   use osc_par_m
   use rot_par_m
   use scan_par_m
   use string_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Module variables

   character(64), save :: log_level_m

   ! Interfaces

   #:for S in PAR_SUFFIXES

      interface select_par
         module procedure select_par_${S}$_1_
         module procedure select_par_${S}$_v_
      end interface select_par

   #:endfor

   ! Access specifiers

   public :: form_header
   public :: set_log_level
   public :: check_log_level
   public :: select_par
   public :: elem_group_name

   ! Default access

   private

contains

   function form_header(header, underchar)

      character(*), intent(in)           :: header
      character(*), optional, intent(in) :: underchar
      character(:), allocatable          :: form_header

      ! Format the header string

      if(PRESENT(underchar)) then

         if(underchar == '') then

            form_header = TRIM(header) // NEW_LINE('') // &
               REPEAT(' ', LEN(header)) // NEW_LINE('')

         else

            form_header = TRIM(header) // NEW_LINE('') // &
               REPEAT(underchar, LEN(header)/LEN(underchar)) // NEW_LINE('')

         endif

      else

         form_header = TRIM(header) // NEW_LINE('')

      endif

      ! Finish

      return

   end function form_header

   !****

   subroutine set_log_level(log_level)

      character(*), intent(in) :: log_level

      ! Set the log level

      select case (log_level)
      case ('DEBUG')
      case ('INFO')
      case ('WARN')
      case default
         @:ABORT('Invalid log_level')
      end select

      log_level_m = log_level

      ! Finish

      return

   end subroutine set_log_level

   !****

   function check_log_level(log_level)

      character(*), intent(in) :: log_level
      logical                  :: check_log_level

      ! Check whether we should write log output

      select case (log_level)
      case ('DEBUG')
         check_log_level = log_level_m == 'DEBUG'
      case ('INFO')
         check_log_level = log_level_m == 'INFO' .OR. &
            log_level_m == 'DEBUG'
      case ('WARN')
         check_log_level = log_level_m == 'WARN' .OR. &
            log_level_m == 'INFO' .OR. &
            log_level_m == 'DEBUG'
      case default
         @:ABORT('invalid log_level')
      end select

      ! Finish

      return

   end function check_log_level

   !****

   #:for N, T, S in zip(PAR_NAMES, PAR_TYPES, PAR_SUFFIXES)

      subroutine select_par_${S}$_1_(par, tag, par_sel)

         ${T}$, intent(in)        :: par(:)
         character(*), intent(in) :: tag
         ${T}$, intent(out)       :: par_sel

         ${T}$, allocatable :: par_sel_(:)

         ! Select the last parameter whose tag_list matches tag

         call select_par(par, tag, par_sel_)

         par_sel = par_sel_(SIZE(par_sel_))

         ! Finish

         return

      end subroutine select_par_${S}$_1_

      !****

      subroutine select_par_${S}$_v_(par, tag, par_sel)

         ${T}$, intent(in)               :: par(:)
         character(*), intent(in)        :: tag
         ${T}$, allocatable, intent(out) :: par_sel(:)

         integer :: i
         logical :: mask(SIZE(par))
         integer :: n_par_sel
         integer :: j

         ! Select all parameters whose tag_list matches tag

         mask_loop : do i = 1,SIZE(par)
            mask(i) = (par(i)%tag_list == '') .OR. &
               (tag /= '' .AND. ANY(split_list(par(i)%tag_list, ',') == tag))
         end do mask_loop

         n_par_sel = COUNT(mask)

         @:ASSERT(n_par_sel >= 1, 'no matching &${N}$ namelists')

         par_sel = PACK(par, mask)

         ! Finish

         return

      end subroutine select_par_${S}$_v_

   #:endfor

   !****

   function elem_group_name(prefix, indices) result(group_name)

      character(*), intent(in)  :: prefix
      integer, intent(in)       :: indices(:)
      character(:), allocatable :: group_name

      integer                   :: n_indices
      character(:), allocatable :: name_format
      integer                   :: name_len
      integer                   :: i

      ! Set up an array-element group name

      n_indices = SIZE(indices)

      select case(n_indices)
      case(0)
         name_format = '(A,''()'')'
      case(1)
         name_format = '(A,''('',I0,'')'')'
      case default
         name_format = '(A,''('''//REPEAT('I0,'',''', n_indices-1)//'I0,'')'')'
      end select

      name_len = LEN_TRIM(prefix) + n_indices + 1

      do i = 1,SIZE(indices)
         if(indices(i) < 0) then
            name_len = name_len + FLOOR(LOG10(REAL(ABS(indices(i))))) + 2
         elseif(indices(i) > 0) then
            name_len = name_len + FLOOR(LOG10(REAL(indices(i)))) + 1
         else
            name_len = name_len + 1
         endif
      end do

      allocate(character(name_len) :: group_name)

      write(group_name, name_format) TRIM(prefix), indices

      ! Finish

      return

   end function elem_group_name

end module util_m
