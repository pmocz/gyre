! Module  : string_m
! Purpose : string manipulation routines
!
! Copyright 2013-2020 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module string_m

   ! Uses

   use forum_m

   use status_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Interfaces

   interface parse_value
      module procedure parse_value_i_
      module procedure parse_value_r_
      module procedure parse_value_l_
   end interface parse_value

   interface parse_values
      module procedure parse_values_i_
      module procedure parse_values_r_
      module procedure parse_values_l_
      module procedure parse_values_a_
   end interface parse_values

   ! Access specifiers

   public :: split_list
   public :: parse_value
   public :: parse_values
   public :: join_fmts
   public :: sprint
   public :: subst
   public :: rjust

   ! Default access

   private

contains

   function split_list(list, delim, unique) result(elems)

      character(*), intent(in)          :: list
      character(1), intent(in)          :: delim
      logical, intent(in), optional     :: unique
      character(LEN(list)), allocatable :: elems(:)

      character(LEN(list)) :: list_
      integer              :: d
      integer              :: n
      integer              :: j

      ! Split the delimited list into an array of elements

      d = 16

      allocate(elems(d))

      n = 0

      ! Repeatedly split on delimiters

      list_ = list

      split_loop : do

         if(list_ == '') exit split_loop

         j = INDEX(list_, delim)

         if(j <= 0) then
            n = n + 1
            elems(n) = ADJUSTL(list_)
            exit split_loop
         endif

         n = n + 1

         ! Chop out the element

         elems(n) = ADJUSTL(list_(:j-1))
         list_ = list_(j+1:)

         ! If necessary, expand the array

         if(n >= d) then
            d = 2*d
            call reallocate(elems, [d])
         end if

      end do split_loop

      ! Reallocate elems to the correct length

      call reallocate(elems, [n])

      ! If necessary, subset to unique items

      if (PRESENT(unique)) then
         if (unique) then
            elems = elems(unique_indices(elems))
         end if
      end if

      ! Finish

      return

   end function split_list

   !****

   #:for type, suffix in (('integer', 'i'), ('real(RD)', 'r'), ('logical', 'l'))

      subroutine parse_value_${suffix}$_(string, value, stat)

         character(*), intent(in)           :: string
         ${type}$, allocatable, intent(out) :: value
         integer, intent(out), optional     :: stat

         integer :: iostat

         ! Parse the string into a value

         parse_block: block

            allocate(value)

            read(string, FMT=*, IOSTAT=iostat) value
            if (iostat /= 0) exit parse_block

            return

         end block parse_block

         if (PRESENT(stat)) then
            stat = STAT_INVALID_ARGUMENT
         else
            @:ABORT('invalid argument')
         end if

         ! Finish

         return

      end subroutine parse_value_${suffix}$_

      !****

      subroutine parse_values_${suffix}$_(string, values, stat, delim)

         character(*), intent(in)           :: string
         ${type}$, allocatable, intent(out) :: values(:)
         integer, intent(out), optional     :: stat
         character(*), intent(in), optional :: delim

         character(:), allocatable :: values_str(:)
         integer                   :: i
         integer                   :: iostat

         ! Parse the string into list of values, with delim as the
         ! separator

         call parse_values(string, values_str, stat, delim)

         parse_block: block

            allocate(values(SIZE(values_str)))

            do i = 1, SIZE(values)
               read(values_str(i), FMT=*, IOSTAT=iostat) values(i)
               if (iostat /= 0) exit parse_block
            end do

            return

         end block parse_block

         if (PRESENT(stat)) then
            stat = STAT_INVALID_ARGUMENT
         else
            @:ABORT('invalid argument')
         end if

         ! Finish

         return

      end subroutine parse_values_${suffix}$_

   #:endfor

   !****

   subroutine parse_values_a_(string, values, stat, delim)

      character(*), intent(in)               :: string
      character(:), allocatable, intent(out) :: values(:)
      integer, intent(out), optional         :: stat
      character(*), intent(in), optional     :: delim

      character(:), allocatable :: delim_
      integer, allocatable      :: i_delim(:)
      integer                   :: i
      integer, allocatable      :: i_sub_a(:)
      integer, allocatable      :: i_sub_b(:)
      integer                   :: n

      if (PRESENT(delim)) then
         delim_ = delim
      else
         delim_ = ','
      end if

      ! Parse the string into a list of values, with delim as the
      ! separator

      ! Determine the indices of delimeters

      allocate(i_delim(0))

      do i = 1, LEN(string)
         if (string(i:i) == delim_) i_delim = [i_delim,i]
      end do

      ! Determine the indices of substrings

      i_sub_a = [1, i_delim+1]
      i_sub_b = [i_delim-1, LEN(string)]

      ! Extract the values from the string

      n = SIZE(i_delim) + 1

      allocate(character(MAXVAL(i_sub_b-i_sub_a+1))::values(n))

      do i = 1, n
         values(i) = string(i_sub_a(i):i_sub_b(i))
      end do

      if (PRESENT(stat)) stat = STAT_OK

      ! Finish

      return

   end subroutine parse_values_a_

   !****

   function join_fmts(fmts, n) result(fmt)

      character(*), intent(in)  :: fmts(:)
      integer, intent(in)       :: n(:)
      character(:), allocatable :: fmt

      integer :: i

      @:CHECK_BOUNDS(SIZE(n), SIZE(fmts))

      ! Join format strings with the appropriate repeat counts

      if(SUM(n) > 0) then

         do i = 1, SIZE(fmts)

            if(ALLOCATED(fmt)) then
               fmt = fmt//','//sprint(n(i))//fmts(i)
            else
               fmt = sprint(n(i))//fmts(i)
            endif

         end do

      else

         fmt = ''

      endif

      ! Add wrap-around parens

      fmt = '('//fmt//')'

      ! Finish

      return

   end function join_fmts

   !****

   function sprint(i) result(a)

      integer, intent(in)       :: i
      character(:), allocatable :: a

      integer :: n

      ! Print an integer into a character

      ! First, determine the length

      if(i > 0) then
         n = FLOOR(log10(REAL(i))) + 1
      elseif(i < 0) then
         n = FLOOR(log10(REAL(abs(i)))) + 2
      else
         n = 1
      endif

      allocate(character(n)::a)

      ! Do the conversion

      write(a, 100) i
100   format(I0)

      ! Finish

      return

   end function sprint

   !****

   function subst(string, pattern, i, format) result(new_string)

      character(*), intent(in)  :: string
      character(*), intent(in)  :: pattern
      integer, intent(in)       :: i
      character(*), intent(in)  :: format
      character(:), allocatable :: new_string

      character(64) :: substring

      ! Write i into the substring buffer

      write(substring, format) i

      ! Do the replacement

      new_string = replace(string, pattern, TRIM(substring), every=.TRUE.)

      ! Finish

      return

   end function subst

   !****

   function rjust(a, n) result(a_just)

      character(*), intent(in) :: a
      integer, intent(in)      :: n
      character(n)             :: a_just

      ! Right-justify a in a field width of n

      a_just = REPEAT(' ', MAX(n-LEN_TRIM(a), 0))//a

      ! Finish

      return

   end function rjust

end module string_m
