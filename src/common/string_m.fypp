! Module  : string_m
! Purpose : string manipulation routines
!
! Copyright 2013-2020 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

module string_m

   ! Uses

   use forum_m

   use status_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Interfaces

   interface parse_value
      module procedure parse_value_i_
      module procedure parse_value_r_
   end interface parse_value

   interface parse_values
      module procedure parse_values_i_
      module procedure parse_values_r_
      module procedure parse_values_a_
   end interface parse_values

   interface parse_name_value
      module procedure parse_name_value_r_
      module procedure parse_name_value_i_
   end interface parse_name_value

   interface parse_name_values
      module procedure parse_name_values_r_
      module procedure parse_name_values_i_
   end interface parse_name_values

   ! Access specifiers

   public :: split_list
   public :: parse_value
   public :: parse_values
   public :: parse_name_value
   public :: parse_name_values
   public :: join_fmts
   public :: sprint
   public :: subst
   public :: rjust

   ! Default access

   private

contains

   function split_list(list, delim, unique) result(elems)

      character(*), intent(in)          :: list
      character(1), intent(in)          :: delim
      logical, intent(in), optional     :: unique
      character(LEN(list)), allocatable :: elems(:)

      character(LEN(list)) :: list_
      integer              :: d
      integer              :: n
      integer              :: j

      ! Split the delimited list into an array of elements

      d = 16

      allocate(elems(d))

      n = 0

      ! Repeatedly split on delimiters

      list_ = list

      split_loop : do

         if(list_ == '') exit split_loop

         j = INDEX(list_, delim)

         if(j <= 0) then
            n = n + 1
            elems(n) = ADJUSTL(list_)
            exit split_loop
         endif

         n = n + 1

         ! Chop out the element

         elems(n) = ADJUSTL(list_(:j-1))
         list_ = list_(j+1:)

         ! If necessary, expand the array

         if(n >= d) then
            d = 2*d
            call reallocate(elems, [d])
         end if

      end do split_loop

      ! Reallocate elems to the correct length

      call reallocate(elems, [n])

      ! If necessary, subset to unique items

      if (PRESENT(unique)) then
         if (unique) then
            elems = elems(unique_indices(elems))
         end if
      end if

      ! Finish

      return

   end function split_list

   !****

   !****

   #:for type, suffix in (('integer', 'i'), ('real(RD)', 'r'))

      subroutine parse_value_${suffix}$_(string, value, stat)

         character(*), intent(in)           :: string
         ${type}$, allocatable, intent(out) :: value
         integer, intent(out), optional     :: stat

         integer :: iostat

         ! Parse the string into a value

         parse_block: block

            allocate(value)

            read(string, FMT=*, IOSTAT=iostat) value
            if (iostat /= 0) exit parse_block

            return

         end block parse_block

         if (PRESENT(stat)) then
            stat = STAT_INVALID_ARGUMENT
         else
            @:ABORT('invalid argument')
         end if

         ! Finish

         return

      end subroutine parse_value_${suffix}$_

   !****

      subroutine parse_values_${suffix}$_(string, value_a, value_b, stat, delim)

         character(*), intent(in)           :: string
         ${type}$, allocatable, intent(out) :: value_a
         ${type}$, allocatable, intent(out) :: value_b
         integer, intent(out), optional     :: stat
         character(*), intent(in), optional :: delim

         character(:), allocatable :: value_a_str
         character(:), allocatable :: value_b_str
         integer                   :: iostat

         ! Parse the string into a pair of values, with delim as the
         ! separator

         call parse_values(string, value_a_str, value_b_str, stat, delim)

         parse_block: block

            allocate(value_a)

            read(value_a_str, FMT=*, IOSTAT=iostat) value_a
            if (iostat /= 0) exit parse_block

            allocate(value_b)

            read(value_b_str, FMT=*, IOSTAT=iostat) value_b
            if (iostat /= 0) exit parse_block

            return

         end block parse_block

         if (PRESENT(stat)) then
            stat = STAT_INVALID_ARGUMENT
         else
            @:ABORT('invalid argument')
         end if

         ! Finish

         return

      end subroutine parse_values_${suffix}$_

      !****

      subroutine parse_name_value_${suffix}$_(string, name, value, stat, delim)

         character(*), intent(in)               :: string
         character(:), allocatable, intent(out) :: name
         ${type}$, allocatable, intent(out)     :: value
         integer, intent(out), optional         :: stat
         character(*), intent(in), optional     :: delim

         character(:), allocatable :: value_str

         ! Parse the string into a name and a value, with delim as the
         ! separator

         call parse_values(string, name, value_str, stat, delim)
         if (PRESENT(stat)) then
            if (stat /= 0) return
         end if

         allocate(value)

         call parse_value(value_str, value, stat)

         ! Finish

         return

      end subroutine parse_name_value_${suffix}$_

      !****

      subroutine parse_name_values_${suffix}$_(string, name, value_a, value_b, stat, delim)

         character(*), intent(in)               :: string
         character(:), allocatable, intent(out) :: name
         ${type}$, allocatable, intent(out)     :: value_a
         ${type}$, allocatable, intent(out)     :: value_b
         integer, intent(out), optional         :: stat
         character(*), intent(in), optional     :: delim

         character(:), allocatable :: values_str

         ! Parse the string into a name and a pair of values, with delim
         ! as the separator

         call parse_values(string, name, values_str, stat, delim)
         if (PRESENT(stat)) then
            if (stat /= 0) return
         end if

         call parse_values(values_str, value_a, value_b, stat, delim)

         ! Finish

         return

      end subroutine parse_name_values_${suffix}$_

   #:endfor

   !****

   subroutine parse_values_a_(string, value_a, value_b, stat, delim)

      character(*), intent(in)               :: string
      character(:), allocatable, intent(out) :: value_a
      character(:), allocatable, intent(out) :: value_b
      integer, intent(out), optional         :: stat
      character(*), intent(in), optional     :: delim

      character(:), allocatable :: delim_

      if (PRESENT(delim)) then
         delim_ = delim
      else
         delim_ = ':'
      end if

      ! Parse the string into a pair of values, with delim as the
      ! separator

      value_b = string
      call split(value_b, value_a, delim_)

      if (PRESENT(stat)) stat = STAT_OK

      ! Finish

      return

   end subroutine parse_values_a_

   !****

   function join_fmts(fmts, n) result(fmt)

      character(*), intent(in)  :: fmts(:)
      integer, intent(in)       :: n(:)
      character(:), allocatable :: fmt

      integer :: i

      @:CHECK_BOUNDS(SIZE(n), SIZE(fmts))

      ! Join format strings with the appropriate repeat counts

      if(SUM(n) > 0) then

         do i = 1, SIZE(fmts)

            if(ALLOCATED(fmt)) then
               fmt = fmt//','//sprint(n(i))//fmts(i)
            else
               fmt = sprint(n(i))//fmts(i)
            endif

         end do

      else

         fmt = ''

      endif

      ! Add wrap-around parens

      fmt = '('//fmt//')'

      ! Finish

      return

   end function join_fmts

   !****

   function sprint(i) result(a)

      integer, intent(in)       :: i
      character(:), allocatable :: a

      integer :: n

      ! Print an integer into a character

      ! First, determine the length

      if(i > 0) then
         n = FLOOR(log10(REAL(i))) + 1
      elseif(i < 0) then
         n = FLOOR(log10(REAL(abs(i)))) + 2
      else
         n = 1
      endif

      allocate(character(n)::a)

      ! Do the conversion

      write(a, 100) i
100   format(I0)

      ! Finish

      return

   end function sprint

   !****

   function subst(string, pattern, i, format) result(new_string)

      character(*), intent(in)  :: string
      character(*), intent(in)  :: pattern
      integer, intent(in)       :: i
      character(*), intent(in)  :: format
      character(:), allocatable :: new_string

      character(64) :: substring

      ! Write i into the substring buffer

      write(substring, format) i

      ! Do the replacement

      new_string = replace(string, pattern, TRIM(substring), every=.TRUE.)

      ! Finish

      return

   end function subst

   !****

   function rjust(a, n) result(a_just)

      character(*), intent(in) :: a
      integer, intent(in)      :: n
      character(n)             :: a_just

      ! Right-justify a in a field width of n

      a_just = REPEAT(' ', MAX(n-LEN_TRIM(a), 0))//a

      ! Finish

      return

   end function rjust

end module string_m
