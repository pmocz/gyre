! Program : build_poly
! Purpose : build a composite polytrope
!
! Copyright 2015-2024 Rich Townsend & The GYRE Team
!
! This file is part of GYRE. GYRE is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License as published by the Free Software Foundation, version 3.
!
! GYRE is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
! or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
! License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program.  If not, see <http://www.gnu.org/licenses/>.

#:include 'gyre.inc'

program build_poly

   ! Uses

   use forum_m, only: RD, hdf5io_t, CREATE_FILE, reallocate, arg_parser_t, OPT_REQUIRED_ARG

   use gyre_m

   use lane_emden_m

   use ISO_FORTRAN_ENV

   ! No implicit typing

   implicit none (type, external)

   ! Parameters

   integer, parameter :: D = 128

   ! Variables

   character(:), allocatable :: file_name
   real(RD), allocatable     :: n_poly(:)
   real(RD), allocatable     :: Gamma_1
   real(RD), allocatable     :: z_b(:)
   real(RD), allocatable     :: Delta_b(:)
   real(RD), allocatable     :: theta_s
   real(RD), allocatable     :: dz
   real(RD), allocatable     :: toler

   type(arg_parser_t)        :: arg_parser
   integer                   :: n_r
   real(RD), allocatable     :: z(:)
   real(RD), allocatable     :: theta(:)
   real(RD), allocatable     :: dtheta(:)
   integer                   :: n_r_out
   type(hdf5io_t)            :: hi

   ! Parse command-line arguments

   Gamma_1 = 5._RD/3._RD
   theta_s = 0._RD
   toler = 1E-10_RD

   allocate(z_b(0))
   allocate(Delta_b(0))

   arg_parser = arg_parser_t('build_poly POLY_FILE', auto_help=.TRUE.)

   call arg_parser%define_option('n_poly', OPT_REQUIRED_ARG, 'n', &
      usage='--n_poly=N_POLY[,N_POLY...]', description='polytropic indices')
   call arg_parser%define_option('Gamma_1', OPT_REQUIRED_ARG, 'G', &
      usage='--Gamma_1=GAMMA_1', description='adiabatic exponent')
   call arg_parser%define_option('z_b', OPT_REQUIRED_ARG, 'z', &
      usage='--z_b=Z_B[,Z_B...]', description='polytropic coordinates of region boundaries')
   call arg_parser%define_option('Delta_b', OPT_REQUIRED_ARG, 'D', &
      usage='--Delta_b=DELTA_B[,DELTA_B...]', description='logarithmic density jumps at region boundaries')
   call arg_parser%define_option('theta_s', OPT_REQUIRED_ARG, &
      usage='--theta_s=THETA_S', description='surface polytropic variable value')
   call arg_parser%define_option('dz', OPT_REQUIRED_ARG, 'd', &
      usage='--dz=DZ', description='grid spacing in polytropic coordinate')
   call arg_parser%define_option('toler', OPT_REQUIRED_ARG, 't', &
      usage='--toler=TOLER', description='tolerance')

   call arg_parser%parse(arg_proc, opt_proc)

   if (.NOT. ALLOCATED(file_name)) call print_summary()

   if (.NOT. ALLOCATED(n_poly)) then
      @:STOP('--n_poly must be specified')
   end if

   n_r = SIZE(n_poly)

   if (SIZE(z_b) /= n_r-1) then
      @:STOP('SIZE(z_b) must match SIZE(n_poly)-1')
   end if

   if (SIZE(Delta_b) /= n_r-1) then
      @:STOP('SIZE(Delta_b) must match SIZE(n_poly)-1')
   end if

   ! Solve the Lane-Emden equation

   call solve_lane_emden(n_poly, z_b, Delta_b, theta_s, dz, toler, z, theta, dtheta, n_r_out)

   if (n_r_out < n_r) then
      write(OUTPUT_UNIT, 100) 'Warning: only', n_r_out, 'of', n_r, 'regions used'
100   format(A,1X,I0,1X,A,1X,I0,1X,A)
   endif

   ! Write the model

   hi = hdf5io_t(file_name, CREATE_FILE)

   call hi%write_attr('n', SIZE(z))
   call hi%write_attr('n_r', n_r)
   call hi%write_attr('n_poly', n_poly)
   if (n_r > 1) then
      call hi%write_attr('Delta_b', Delta_b)
   endif
   call hi%write_attr('Gamma_1', Gamma_1)

   call hi%write_dset('z', z)
   call hi%write_dset('theta', theta)
   call hi%write_dset('dtheta', dtheta)

   call hi%final()

   ! Finish

contains

   subroutine arg_proc(a, value)

      integer, intent(in)      :: a
      character(*), intent(in) :: value

      select case(a)
      case(1)
         file_name = value
      case default
         call print_summary()
      end select

   end subroutine arg_proc

   !****

   subroutine opt_proc(name, value)

      character(*), intent(in) :: name
      character(*), intent(in) :: value

      integer :: stat

      stat = STAT_OK

      select case(name)
      case('n_poly')
         call parse_values(value, n_poly)
      case('Gamma_1')
         call parse_value(value, Gamma_1)
      case('z_b')
         call parse_values(value, z_b)
      case('Delta_b')
         call parse_values(value, Delta_b)
      case('theta_s')
         call parse_value(value, theta_s)
      case('dz')
         call parse_value(value, dz)
      case('toler')
         call parse_value(value, toler)
      case('help')
         call print_summary()
      case default
         @:ABORT('invalid option name')
      end select

      if (stat /= STAT_OK) then
         @:STOP('invalid --'//name)
      end if

   end subroutine opt_proc

   !****

   subroutine print_summary()

      call arg_parser%print_summary()
      @:STOP()

   end subroutine print_summary

end program build_poly
